lets start with some shell commands
date  shows date
cal   calender
df    To see the current amount of free space on your disk drives
du    To see the directory space uses
exit  it is what the name says
cd    change directory
file filename tells a lot about file
ls 	list(it has lot of arguments like ls -l/-a/...)
less command is a program to view text files.
for eg: less today.txt

https://upload.wikimedia.org/wikipedia/commons/thumb/f/f3/Standard-unix-filesystem-hierarchy.svg/1920px-Standard-unix-filesystem-hierarchy.svg.png

apropos - search the manual page names and descriptions
whoami 	Displays current username.
id 	Returns users identity
hostname 	Sets or prints the name of current host system.
uname 	Prints basic information about the operating system name and system hardware.
pwd 	Returns working directory name.
ifconfig 	The ifconfig utility is used to assign or to view an address to a network interface and/or configure network interface parameters.
ip 	Ip is a utility to show or manipulate routing, network devices, interfaces and tunnels.
netstat 	Shows network status.
ss 	Another utility to investigate sockets.
ps 	Shows process status.
who 	Displays who is logged in.
env 	Prints environment or sets and executes command.
lsblk 	Lists block devices.
lsusb 	Lists USB devices
lsof 	Lists opened files.
lspci 	Lists PCI devices.
uname - print system information
●cp – Copy files and directories
●mv – Move/rename files and directories
●mkdir – Create directories
	mkdir -p (parents) can make sub directory
●rm – Remove files and directories
●ln – Create hard and symbolic links(like copy but change in one file change in other file)

Read about wildcard 
for eg 
*   All files
g*  Any file beginning with “g”
b*.txt  Any file beginning with “b” followed by any characters and ending with “.txt”
type – Display A Command's Type
which – Display An Executable's Location
man – Display A Program's Manual Page
whatis – Display A Very Brief Description Of A Command
info – Display A Program's Info Entry

create own command
alias foo='cd /usr; ls; cd -'
	$ type foo
foo is aliased to `cd /usr; ls ; cd -'

remove alias
unalias foo

cat – Concatenate Files(In most cases, you can think of cat as being analogous to the TYPE command in DOS.
You can use it to display files without paging)
cat > lazy_dog.txt
The quick brown fox jumped over the lazy dog.
ctrl+d to say it is the end of file 
and again cat lazy_dog.txt to copy file to stdout in terminal

Pipelines
The ability of commands to read data from standard input and send to standard output is utilized by a shell feature called pipelines.
Using the pipe operator “|” (vertical bar), the standard output of one command can be piped into the standard input of another:
for eg : ls -l /usr/bin | less

The Difference Between > and |

At first glance, it may be hard to understand the redirection performed by the
pipeline operator | versus the redirection operator >. Simply put, the redirection
operator connects a command with a file while the pipeline operator connects the
output of one command with the input of a second command.
command1 > file1
command1 | command2
A lot of people will try the following when they are learning about pipelines, “just to see what happens.”
command1 > command2

"Answer: Sometimes something really bad."
Here is an actual example submitted by a reader who was administering a Linux-
based server appliance. As the superuser, he did this:
# cd /usr/bin
# ls > less
The first command put him in the directory where most programs are stored and the second command told the shell to overwrite the file less with 
the output of the ls command. Since the /usr/bin directory already contained a file named “less” (the less program), the second command overwrote the 
less program file with the text from ls thus destroying the less program on his system.
The lesson here is that the redirection operator silently creates or overwrites files, so you need to treat it with a lot of respect.

Filters : it take input, change it somehow and then output it.
for eg
ls /bin /usr/bin | sort | less

uniq - Report Or Omit Repeated Lines

wc – Print Line, Word, And Byte Counts
The wc (word count) command is used to display the number of lines, words, and bytes
contained in files. For example:
❯ wc shell 
  96  711 4312 shell
  
grep - grep is a powerful program used to find text patterns within files. It's used like this:
grep pattern [file...]
Let's say we wanted to find all the files in our list of programs that had the word “zip” embedded in the name. Such a search might give us an 
idea of some of the programs on our system that had something to do with file compression. We would do this:
$ ls /bin /usr/bin | sort | uniq | grep zip

head / tail – Print First / Last Part Of Files(10 LINE)
head -n 5 ls-output.txt (-n can manupalate)
ls /usr/bin | tail -n 5

tail -f /var/log/messages
-f let you see real time append in file 

tee – Read From Stdin And Output To Stdout And Files
Here we repeat one of our earlier examples, this time including tee to capture the entire directory listing to the file ls.txt 
before grep filters the pipeline's contents:
ls /usr/bin | tee ls.txt | grep zip

SUMMING UP
Linux Is About Imagination
When I am asked to explain the difference between Windows and Linux, I often
use a toy analogy.
Windows is like a Game Boy. You go to the store and buy one all shiny new in the
box. You take it home, turn it on and play with it. Pretty graphics, cute sounds.
After a while though, you get tired of the game that came with it so you go back
to the store and buy another one. This cycle repeats over and over. Finally, you go
back to the store and say to the person behind the counter, “I want a game that
does this!” only to be told that no such game exists because there is no “market
demand” for it. Then you say, “But I only need to change this one thing!” The
person behind the counter says you can't change it. The games are all sealed up in
their cartridges. You discover that your toy is limited to the games that others
have decided that you need and no more.
Linux, on the other hand, is like the world's largest Erector Set. You open it up
and it's just a huge collection of parts. A lot of steel struts, screws, nuts, gears,
pulleys, motors, and a few suggestions on what to build. So you start to play with
it. You build one of the suggestions and then another. After a while you discover
that you have your own ideas of what to make. You don't ever have to go back to
the store, as you already have everything you need. The Erector Set takes on the
shape of your imagination. It does what you want.
Your choice of toys is, of course, a personal thing, so which toy would you find
more satisfying?

Seeing The World As The Shell Sees It

echo – Display a line of text
but see what  echo * does 
have you seen * as output NO? why you ask
cuz when you enter the command shell automaticall expand any qualifying character 
which if you have read the wild card * is everything something like that read it

Arithematic expression
echo $((2 + 2))
 see two bracket why you ask cuz its the syntax!!!!!! sorry i cant change it;
echo $(($((5**2)) * 3))
try this and know why
but remember only interger

Brace Expansion
Perhaps the strangest expansion is called brace expansion. With it, you can create multiple text strings from a pattern containing braces
echo Front-{A,B,C}-Back
Front-A-Back Front-B-Back Front-C-Back
awesome command but weird WHAT DO YOU EXPECT IT WAS RELESED 1989
TRY echo Number_{1..5}
echo a{A{1,2},B{3,4}}b
You can even make file using this 
ACTUALLY IT WILL BE EASY IF YOU LEARN BASH SCRIPT BUT WAIT THEIR IS MORE I WILL TELL YOU TO READ WHEN TO

echo $USER
user variable consist of your system user name 

To see a list of available variables, try this:	printenv | less

Command Substitution
echo $(ls)
Desktop Documents ls-output.txt Music Pictures Public Templates

Quoting
Now that we've seen how many ways the shell can perform expansions, it's time to learn how we can control it. Take for example:
[me@linuxbox ~]$ echo this is a		test
this is a test
or:
[me@linuxbox ~]$ echo The total is $100.00
The total is 00.00
In the first example, word-splitting by the shell removed extra whitespace from the echo
command's list of arguments. In the second example, parameter expansion substituted an
empty string for the value of “$1” because it was an undefined variable. The shell pro-
vides a mechanism called quoting to selectively suppress unwanted expansions.

Double Quotes
Using double quotes, we can cope with filenames con-
taining embedded spaces. Say we were the unfortunate victim of a file called two words.txt. If we tried to use this on the command line, word-splitting 
would cause this to be treated as two separate arguments rather than the desired single argument:
[me@linuxbox ~]$ ls -l two words.txt
ls: cannot access two: No such file or directory
ls: cannot access words.txt: No such file or directory
so we use "two words.txt"

Remember, parameter expansion, arithmetic expansion, and command substitution still
take place within double quotes:
[me@linuxbox ~]$ echo "$USER $((2+2)) $(cal)"

Single Quotes
If we need to suppress all expansions, we use single quotes. Here is a comparison of un-
quoted, double quotes, and single quotes:

Escaping Characters
Sometimes we only want to quote a single character. To do this, we can precede a charac-
ter with a backslash, which in this context is called the escape character. Often this is
done inside double quotes to selectively prevent an expansion:

Advanced Keyboard Tricks
Command Line Editing
since the mouse is no use so keyboard is the key u see what i did with the word ahh

Ctrl-a	Move cursor to the beginning of the line.
Ctrl-e	Move cursor to the end of the line.
Ctrl-f	Move cursor forward one character; same as the right arrow key.
Ctrl-b	Move cursor backward one character; same as the left arrow key.
Alt-f	Move cursor forward one word.
Alt-b	Move cursor backward one word.
Ctrl-l Clear the screen and move the cursor to the top left corner. The
	clear command does the same thing.

Searching History
history | less 
history | grep /usr/bin
!88 shows 88 command in history
ctrl+r in terminal for reverse search
!numberRepeat history list item number.
!stringRepeat last history list item starting with string.
!?stringRepeat last history list item containing string.

●id – Display user identity
●chmod – Change a file's mode
●umask – Set the default file permissions
●su – Run a shell as another user
●sudo – Execute a command as another user
●chown – Change a file's owner
●chgrp – Change a file's group ownership
●passwd – Change a user's password

Reading, Writing, And Executing
try ls -l
it might show somthing like this : drwxr-xr-x
where d - directory it might be - which means regular file 
l - A symbolic link
c - A  character special file
b - A block special file
and rwx means read write and executable

Owner	Group	World
rwx	rwx	rwx

chmod – Change File Mode
it is in octal number system rwx(421)
chmod 600 foo.txt
ls -l foo.txt
-rw------- 1 me

u	Short for “user” but means the file or directory owner.
g	Group owner.
o	Short for “others,” but means world.
a	Short for “all.” The combination of “u”, “g”, and “o”.

and you can do operation like u+x...
umask – Set Default Permissions
works on octal number system 
for default it is 0 0 2 2  I'll say what does this means and why 4 instead of 3
originally if you create the file you will see it will have -rw-rw-r--
because if you write umask it will give you output of 002
cuz Original file mode  --- rw- rw- rw-
    Mask		000 000 000 010(2)
    Result		--- rw- rw- r--
    
Again, where a 1 appears in the binary value, the corresponding attribute is unset. Play
with some values (try some sevens) to get used to how this works. When you're done, re-
member to clean up:
    
When we set the mask to 0000 (effectively turning it off)
Original file mode--- rw- rw- rw-
Mask		  000 000 000 000
Result		  --- rw- rw- rw-


su – Run A Shell With Substitute User And Group IDs
also known as super user

chown can change the file owner and/or the file group owner depending on the first ar-
gument of the command. it is needed if you have  more than one user in the device
 
Let's say that we have two users; janet, who has access to superuser privileges and
tony, who does not. User janet wants to copy a file from her home directory to the
home directory of user tony. Since user janet wants tony to be able to edit the file,
janet changes the ownership of the copied file from janet to tony: sudo cp myfile.txt ~tony

Changing Your Password
passwd [user]

How A Process Works(have you heard of init?)
When a system starts up, the kernel initiates a few of its own activities as processes and
launches a program called init. init, in turn, runs a series of shell scripts (located in
/etc) called init scripts, which start all the system services. Many of these services are
implemented as daemon programs, programs that just sit in the background and do their
thing without having any user interface. So even if we are not logged in, the system is at
least a little busy performing routine stuff.
The fact that a program can launch other programs is expressed in the process scheme as
a parent process producing a child process.

kernel organize each process and gives it a unique id ie pid.it also keep track of memory used
owner and so on.PIDs are assigned in ascending order, with init always getting PID 1.

Viewing Processes - ps
~ps
PID TTY 	TIME CMD
5198 pts/1	00:00:00 bash
10129 pts/1	00:00:00 ps
The result in this example lists two processes, process 5198 and process 10129, which are
bash and ps respectively. As we can see, by default, ps doesn't show us very much, just
the processes associated with the current terminal session. To see more, we need to add
some options, but before we do that, let's look at the other fields produced by ps. TTY is
short for “Teletype,” and refers to the controlling terminal for the process. Unix is show-
ing its age here. The TIME field is the amount of CPU time consumed by the process. As
we can see, neither process makes the computer work very hard.
If we add an option, we can get a bigger picture of what the system is doing:

Running. This means that the process is running or ready to run.
Sleeping. The process is not running; rather, it is waiting for an
event, such as a keystroke or network packet.
D	Uninterruptible Sleep. Process is waiting for I/O such as a diskdrive.
T	Stopped. Process has been instructed to stop. More on this later.
Z	A defunct or “zombie” process. This is a child process that has
	terminated, but has not been cleaned up by its parent.
<	A high priority process. It's possible to grant more importance to a
	process, giving it more time on the CPU. This property of a process
	is called niceness. A process with high priority is said to be less nice
	because it's taking more of the CPU's time, which leaves less for
	everybody else.
N	A low priority process. A process with low priority (a “nice”
	process) will only get processor time

Another popular set of options is “aux” (without a leading dash). This gives us even more
information:ps aux
To 1mmand

xlogo program is a sample program supplied with the X Window System
$ xlogo 
just shows xlogo 
but see in terminal you cant type other command when xlogo is running
so we will learn about running,background programs,and many other thing
we can do control+c to exit any running program in terminal
we can even put the process in background
$ xlogo& 
this & will let you write other command while xlogo is running in background
we can see the programs runned through this terminal by "jobs" command
we can return to the background programs by
do jobs then it will show the running background programs then it is given a certain number for
it's indication and then we can go to background programs by fg(foreground) command 
fg %1
%1 indicate the first bg program then we can control+c to exit the program
example if you run spotify or discord in terminal it will be running program and you can
send it to background or exit it and so on.
bg - background how to use this command for example you are running spotify it will run until it is 
stopped in terminal so to run it you can suspend by control+z 
and do jobs and bg %[number] to run in background

Or we can use top command and kill the running programs through kill command
syntax is kill [pid]
try it you will know 
kill has many signals like int,KILL,stop,cont...etc try reading it
you can kill multiple windows all at one by killall command it don't need pids
$killall firefox

pstree	Outputs a process list arranged in a tree-like pattern showing the
	parent/child relationships between processes.
vmstat	Outputs a snapshot of system resource usage including, memory,
	swap and disk I/O. To see a continuous display, follow the
	command with a time delay (in seconds) for updates.
xloadA  graphical program that draws a graph showing system load over
	time.
tload   Similar to the xload program, but draws the graph in the terminal.
	Terminate the output with Ctrl-c

ENVIRONMENT

printenv – Print part or all of the environment 
$printenv | less
What we see is a list of environment variables and their values. For example, we see a
variable called USER, which contains the value “me”. The printenv command can
also list the value of a specific variable	
 their is lot of variable which has already a value and cannot be changed and we can
 see these variables by this commands and also be printed by printenv USER
 or we can use echo command like echo $USER to see the value

The set command, when used without options or arguments, will display both the shell
and environment variables, as well as any defined shell functions. Unlike printenv, its
output is courteously sorted in alphabetical order

Startup Files For Login Shell Sessions
FileContents
/etc/profile	A global configuration script that applies to all users.
~/.bash_profile	A user's personal startup file. Can be used to extend or
		override settings in the global configuration script.
~/.bash_login	If ~/.bash_profile is not found, bash attempts to
		read this script.
~/.profile	If neither ~/.bash_profile nor ~/.bash_login
		is found, bash attempts to read this file. This is the
		default in Debian-based distributions, such as Ubuntu.
Startup Files For Non-Login Shell Sessions
FileContents
/etc/bash.bashrc	A global configuration script that applies to all users.
~/.bashrc		A user's personal startup file. Can be used to extend or
			override settings in the global configuration script.
			

